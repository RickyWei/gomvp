// go:build ignore
package main

import (
	"bytes"
	"fmt"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"regexp"

	"github.com/AlecAivazis/survey/v2"
	"github.com/Masterminds/sprig"
	"github.com/spf13/pflag"
	"golang.org/x/mod/modfile"
	"gorm.io/gorm/schema"
)

const (
	voTemplate = `
{{- /* remove empty line*/ -}}
// Generated by sparrow
// Generated by sparrow
// Generated by sparrow

package vo

import "{{.Mod}}/po"

type {{.Schema}} = po.{{.Schema}}
`
	handlerTemplate = `
{{- /* remove empty line*/ -}}
// Generated by sparrow
// Generated by sparrow
// Generated by sparrow

package handler

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/jinzhu/copier"
	"github.com/samber/lo"
	"gorm.io/gorm"

	"{{.Mod}}/cache"
	"{{.Mod}}/dao"
	"{{.Mod}}/po"
	"{{.Mod}}/vo"
)

type {{.Schema}}Handler struct{}

func New{{.Schema}}Handler() *{{.Schema}}Handler {
	return &{{.Schema}}Handler{}
}

// Create
//
//	@Tags			{{.Name}}
//	@Description	create
//	@Accept			json
//	@Produce		json
//	@Param			body	body		vo.{{.Schema}}	true	" "
//	@Success		200		{object}	responseWithoutData
//	@Failure		200		{object}	responseWithoutData
//	@Router			/api/v1/{{.Name}} [POST]
func (h *{{.Schema}}Handler) Create(ctx *gin.Context) {
	req := &vo.{{.Schema}}{}
	if err := ctx.BindJSON(req); err != nil {
		ctxJSONWithError(ctx, ERRNO_INVALID_ARGUMENT, err)
		return
	}
	data := &po.{{.Schema}}{}
	if err := copier.Copy(data, req); err != nil {
		ctxJSONWithError(ctx, ERRNO_INVALID_ARGUMENT, err)
		return
	}
	if err := dao.Q.{{.Schema}}.WithContext(ctx).
		Create(data); err != nil {
		ctxJSONWithError(
			ctx,
			lo.Ternary(errors.Is(err, gorm.ErrDuplicatedKey), http.StatusBadRequest, http.StatusInternalServerError),
			err,
		)
		return
	}

	ctxJSONWithoutData(ctx)
}

// Delete
//
//	@Tags			{{.Name}}
//	@Description	delete
//	@Accept			json
//	@Produce		json
//	@Param			id		path		int64	true	" "
//	@Success		200		{object}	responseWithoutData
//	@Failure		200		{object}	responseWithoutData
//	@Router			/api/v1/{{.Name}}/:id [DELETE]
func (h *{{.Schema}}Handler) Delete(ctx *gin.Context) {
	id, err := strconv.ParseInt(ctx.Param("id"), 10, 64)
	if err != nil {
		ctxJSONWithError(ctx, ERRNO_INVALID_ARGUMENT, err)
		return
	}

	if err = dao.Q.{{.Schema}}.WithContext(ctx).
		DeleteByID(id); err != nil {
		ctxJSONWithError(ctx, ERRNO_INTERNAL_ERROR, err)
		return
	}

	if _, err = cache.RC.Del(ctx, fmt.Sprintf("{{.Name}}-%d", id)).Result(); err != nil {
		ctxJSONWithError(ctx, ERRNO_INTERNAL_ERROR, err)
		return
	}

	ctxJSONWithoutData(ctx)
}

// Update
//
//	@Tags			{{.Name}}
//	@Description	update
//	@Accept			json
//	@Produce		json
//	@Param			id		path		int64				true	" "
//	@Param			body	body		vo.{{.Schema}}	true	" "
//	@Success		200		{object}	responseWithoutData
//	@Failure		200		{object}	responseWithoutData
//	@Router			/api/v1/{{.Name}}/:id [PUT]
func (h *{{.Schema}}Handler) Update(ctx *gin.Context) {
	id, err := strconv.ParseInt(ctx.Param("id"), 10, 64)
	if err != nil {
		ctxJSONWithError(ctx, ERRNO_INVALID_ARGUMENT, err)
		return
	}
	data := &po.{{.Schema}}{}
	if err := ctx.BindJSON(data); err != nil {
		ctxJSONWithError(ctx, ERRNO_INVALID_ARGUMENT, err)
		return
	}
	data.ID = id

	if _, err = dao.Q.{{.Schema}}.WithContext(ctx).
		Updates(data); err != nil {
		ctxJSONWithError(ctx, ERRNO_INTERNAL_ERROR, err)
		return
	}

	if _, err = cache.RC.Del(ctx, fmt.Sprintf("{{.Name}}-%d", id)).Result(); err != nil {
		ctxJSONWithError(ctx, ERRNO_INTERNAL_ERROR, err)
		return
	}

	ctxJSONWithoutData(ctx)
}

// Query
//
//	@Tags			{{.Name}}
//	@Description	query
//	@Produce		json
//	@Param			id		path		int64	true	" "
//	@Success		200		{object}	response[po.{{.Schema}}]
//	@Failure		200		{object}	responseWithoutData
//	@Router			/api/v1/{{.Name}}/:id [GET]
func (h *{{.Schema}}Handler) Query(ctx *gin.Context) {
	id, err := strconv.ParseInt(ctx.Param("id"), 10, 64)
	if err != nil {
		ctxJSONWithError(ctx, ERRNO_INVALID_ARGUMENT, err)
		return
	}
	data, err := dao.Q.{{.Schema}}.WithContext(ctx).
		FindByID(id)
	if err != nil {
		ctxJSONWithError(ctx, ERRNO_INVALID_ARGUMENT, err)
		return
	}

	if bs, err := json.Marshal(data); err == nil {
		cache.RC.Del(ctx, fmt.Sprintf("{{.Name}}-%d", bs))
	}

	ctxJSONWithData(ctx, data)
}

// QueryList
//
//	@Tags			{{.Name}}
//	@Description	query list
//	@Produce		json
//	@Param			offset	query		int	true	" "
//	@Param			limit	query		int	true	" "
//	@Success		200		{object}	response[[]po.{{.Schema}}]
//	@Failure		200		{object}	responseWithoutData
//	@Router			/api/v1/{{.Name}} [GET]
func (h *{{.Schema}}Handler) QueryList(ctx *gin.Context) {
	offset, err := strconv.Atoi(ctx.Query("offset"))
	if err != nil {
		ctxJSONWithError(ctx, ERRNO_INVALID_ARGUMENT, err)
		return
	}
	limit, err := strconv.Atoi(ctx.Query("limit"))
	if err != nil {
		ctxJSONWithError(ctx, ERRNO_INVALID_ARGUMENT, err)
		return
	}

	data, total, err := dao.Q.{{.Schema}}.WithContext(ctx).
		FindByPage(offset, limit)
	if err != nil {
		ctxJSONWithError(ctx, ERRNO_INTERNAL_ERROR, err)
		return
	}

	ctxJSONWithListData(ctx, total, data)
}
`
)

type api struct {
	Name   string
	Schema string
	Mod    string
}

func main() {
	var err error
	defer func() {
		if err != nil {
			log.Println(err)
		}
	}()

	a := &api{}
	pflag.StringVarP(&a.Name, "name", "n", "", "handler name in snake case(i.e. your table name). eg. login_audit")
	pflag.Parse()
	if a.Name == "" {
		err = fmt.Errorf("handler name cannot be empty")
		return
	}
	p := "[a-z]+(_[a-z])*"
	match, err := regexp.MatchString(p, a.Name)
	if err != nil {
		return
	}
	if !match {
		err = fmt.Errorf("handler name should in snake case, specifically, %s", p)
		return
	}
	a.Schema = schema.NamingStrategy{}.SchemaName(a.Name)
	if a.Mod, err = findModName(); err != nil {
		return
	}

	if err = generate(a, filepath.Join("..", "vo", a.Name+".go"), voTemplate); err != nil {
		return
	}
	if err = generate(a, filepath.Join("..", "handler", a.Name+".go"), handlerTemplate); err != nil {
		return
	}

	return
}

func findModName() (mod string, err error) {
	modBytes, err := os.ReadFile("../go.mod")
	if err != nil {
		return
	}
	mod = modfile.ModulePath(modBytes)

	return
}

func generate(a *api, fp string, tp string) (err error) {
	t, err := template.New(a.Name).Funcs(sprig.FuncMap()).Parse(tp)
	if err != nil {
		return
	}
	buf := &bytes.Buffer{}
	if err = t.Execute(buf, a); err != nil {
		return
	}

	dst, err := filepath.Abs(fp)
	if err != nil {
		return
	}
	_, err = os.Stat(dst)
	if !os.IsNotExist(err) {
		log.Printf("%s\nalready exists\n", dst)
		prompt := &survey.Confirm{
			Message: "Do you want to override the file?",
			Help:    "",
		}
		confirm := false
		if err = survey.AskOne(prompt, &confirm); err != nil {
			return
		}
		if !confirm {
			return
		}
		if err = os.RemoveAll(dst); err != nil {
			return
		}
	}
	log.Printf("generate -> %s", dst)
	err = os.WriteFile(dst, buf.Bytes(), 0644)

	return
}
